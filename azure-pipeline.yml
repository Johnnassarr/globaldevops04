# =============================================================================
# Azure DevOps Pipeline - EcoTask API
# =============================================================================
# Pipeline de CI/CD - Build, Test, Push para ACR e Deploy
# RM: 556221
# =============================================================================

trigger: none

# PR: Build roda quando PR é criado/atualizado
# O merge na master/main aciona o build
pr:
  branches:
    include:
    - main
    - master
  paths:
    exclude:
    - README.md
    - '*.md'
    - '*.sh'

variables:
  # Build variables
  mavenVersion: '3.9.x'
  jdkVersion: '21'
  
  # Azure Service Connection (IMPORTANTE: Configure este valor no Azure DevOps!)
  # Substitua 'Azure-Service-Connection' pelo nome da sua Service Connection
  azureServiceConnection: 'Azure-Service-Connection'
  
  # Azure variables
  azureRG: 'rg-ecotask-rm556221'
  acrName: 'acrecotaskrm556221'
  acrLoginServer: 'acrecotaskrm556221.azurecr.io'
  location: 'brazilsouth' # Exemplo: Alterado para 'brazilsouth'
  
  # Image variables
  imageName: 'ecotask-api'
  imageTag: '$(Build.BuildId)'
  
  # Database variables (Configure no Azure DevOps como SECRET)
  # dbHost: '<configured-as-variable>'
  # dbPort: '5432'
  # dbName: 'ecotask'
  # dbUser: 'postgres'
  # dbPassword: '<configured-as-secret>'

stages:
# =============================================================================
# STAGE 1: BUILD & TEST (CI)
# =============================================================================
- stage: Build
  displayName: 'Build, Test and Push to ACR'
  jobs:
  - job: BuildJob
    displayName: 'Build Application'
    # NOTA: Usando self-hosted para evitar erro de paralelismo
    # Se você tem paralelismo habilitado, pode mudar para: vmImage: 'ubuntu-latest'
    pool:
      name: 'self-hosted-pool'
    # Alternativa se não tiver self-hosted (requer paralelismo):
    # pool:
    #   vmImage: 'ubuntu-latest'
    
    steps:
    # Checkout code
    - checkout: self
      displayName: 'Checkout Repository'
      clean: true
    
    # Subir PostgreSQL em container para os testes
    - task: Bash@3
      displayName: 'PostgreSQL: Iniciar Container para Testes'
      inputs:
        targetType: 'inline'
        script: |
          echo "Iniciando container PostgreSQL para testes..."
          docker run -d \
            --name postgres-test \
            -e POSTGRES_DB=ecotask_test \
            -e POSTGRES_USER=postgres \
            -e POSTGRES_PASSWORD=postgres \
            -p 5432:5432 \
            postgres:15-alpine
          
          echo "Aguardando PostgreSQL estar pronto..."
          for i in {1..30}; do
            if docker exec postgres-test pg_isready -U postgres &> /dev/null; then
              echo "PostgreSQL está pronto!"
              exit 0
            fi
            echo "Tentativa $i/30..."
            sleep 2
          done
          echo "ERRO: PostgreSQL não ficou pronto a tempo"
          exit 1
    
    # Instalar Java 21 se não estiver instalado
    - task: Bash@3
      displayName: 'Instalar/Verificar Java 21'
      inputs:
        targetType: 'inline'
        script: |
          echo "Verificando Java..."
          
          if command -v java &> /dev/null; then
            JAVA_VERSION=$(java -version 2>&1 | head -n 1 | cut -d'"' -f2 | sed '/^1\./s///' | cut -d'.' -f1)
            echo "Java encontrado: versão $JAVA_VERSION"
            
            if [ "$JAVA_VERSION" -lt "21" ]; then
              echo "Java 21 é necessário. Instalando..."
              sudo apt update
              sudo apt install -y openjdk-21-jdk
            fi
          else
            echo "Java não encontrado. Instalando OpenJDK 21..."
            sudo apt update
            sudo apt install -y openjdk-21-jdk
          fi
          
          echo "Java instalado:"
          java -version
          
          # Configurar JAVA_HOME
          export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which java))))
          echo "JAVA_HOME set to: $JAVA_HOME"
          echo "##vso[task.setvariable variable=JAVA_HOME]$JAVA_HOME"
    
    # Build with Maven Wrapper
    - task: Bash@3
      displayName: 'Maven: Clean and Build'
      inputs:
        targetType: 'inline'
        script: |
          echo "Building with Maven Wrapper..."
          echo "Working directory: $(pwd)"
          
          # Configurar HOME e JAVA_HOME
          if [ -z "$HOME" ]; then
            export HOME=/root
          fi
          
          if [ -z "$JAVA_HOME" ]; then
            export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which java))))
          fi
          
          echo "JAVA_HOME: $JAVA_HOME"
          
          # Dar permissão ao Maven Wrapper
          chmod +x mvnw
          
          # Configurar variáveis de ambiente para conectar ao PostgreSQL do container
          export SPRING_DATASOURCE_URL="jdbc:postgresql://localhost:5432/ecotask_test"
          export SPRING_DATASOURCE_USERNAME="postgres"
          export SPRING_DATASOURCE_PASSWORD="postgres"
          
          # Build com Maven Wrapper (executa testes com PostgreSQL)
          ./mvnw clean package -DskipTests=false
          
          echo ""
          echo "Build completed!"
          echo "Artifact location: target/"
          
          # Verificar se o build gerou o JAR
          if [ -d "target" ]; then
            echo "Directory target/ exists"
            ls -lah target/*.jar 2>/dev/null || echo "No JAR files found"
          else
            echo "ERROR: Directory target/ was not created!"
            exit 1
          fi
    
    # Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish Test Results (JUnit)'
      condition: always()
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        mergeTestResults: true
        failTaskOnFailedTests: false
        testRunTitle: 'Unit Tests - EcoTask'
    
    # Publish build artifact
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Artifact'
      condition: succeeded()
      continueOnError: true
      inputs:
        PathtoPublish: '$(System.DefaultWorkingDirectory)/target'
        ArtifactName: 'target'
        publishLocation: 'Container'
    
    # Parar e remover container PostgreSQL após testes
    - task: Bash@3
      displayName: 'PostgreSQL: Parar Container'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          echo "Parando container PostgreSQL..."
          docker stop postgres-test 2>/dev/null || true
          docker rm postgres-test 2>/dev/null || true
          echo "Container PostgreSQL removido"
    
    # Docker: Build Image
    - task: Docker@2
      displayName: 'Docker: Build Image'
      inputs:
        command: 'build'
        repository: '$(imageName)'
        dockerfile: 'dockerfiles/Dockerfile'
        buildContext: '$(Build.SourcesDirectory)'
        tags: |
          $(imageTag)
          latest
    
    # ACR: Login (Opcional - apenas se ACR estiver configurado)
    - task: Bash@3
      displayName: 'ACR: Docker Login (Opcional)'
      continueOnError: true
      name: ACRLogin
      inputs:
        targetType: 'inline'
        script: |
          echo "Verificando se ACR está configurado..."
          
          # Inicializar variável como false
          echo "##vso[task.setvariable variable=ACR_LOGIN_SUCCESS;isOutput=true]false"
          
          if [ -z "$ACR_PASSWORD" ] || [ -z "$(acrLoginServer)" ]; then
            echo "AVISO: ACR não configurado. Pulando login e push para ACR."
            echo "Para habilitar: Configure as variáveis acrPassword e acrLoginServer no Azure DevOps"
            echo "##vso[task.setvariable variable=ACR_LOGIN_SUCCESS;isOutput=true]false"
            exit 0
          fi
          
          echo "Fazendo login no ACR: $(acrLoginServer)"
          echo "Username: $(acrName)"
          
          # Tentar fazer login
          if echo "$ACR_PASSWORD" | docker login $(acrLoginServer) --username $(acrName) --password-stdin 2>&1; then
            echo "Login realizado com sucesso no ACR!"
            echo "##vso[task.setvariable variable=ACR_LOGIN_SUCCESS;isOutput=true]true"
          else
            echo "AVISO: Falha ao fazer login no ACR. ACR pode não existir ainda."
            echo "Pulando push para ACR. A imagem foi construída localmente."
            echo "##vso[task.setvariable variable=ACR_LOGIN_SUCCESS;isOutput=true]false"
            exit 0
          fi
      env:
        ACR_PASSWORD: $(acrPassword)
    
    # Docker: Tag for ACR (sempre executa, mas verifica se pode fazer)
    - task: Bash@3
      displayName: 'Docker: Tag Images for ACR'
      continueOnError: true
      inputs:
        targetType: 'inline'
        script: |
          echo "Verificando se pode fazer tag para ACR..."
          
          if [ -z "$(acrLoginServer)" ] || [ -z "$(acrPassword)" ]; then
            echo "=========================================="
            echo "ACR não configurado - Pulando tag"
            echo "=========================================="
            echo "Para habilitar:"
            echo "1. Crie o ACR no Azure (use script-infra-provision.sh)"
            echo "2. Configure a variável 'acrPassword' no Azure DevOps"
            echo "=========================================="
            exit 0
          fi
          
          echo "Tagging images for ACR..."
          docker tag $(imageName):$(imageTag) $(acrLoginServer)/$(imageName):$(imageTag)
          docker tag $(imageName):latest $(acrLoginServer)/$(imageName):latest
          echo "Images tagged successfully!"
    
    # Push to ACR (sempre executa, mas verifica se pode fazer)
    - task: Bash@3
      displayName: 'ACR: Push Images'
      continueOnError: true
      inputs:
        targetType: 'inline'
        script: |
          echo "Verificando se pode fazer push para ACR..."
          
          if [ -z "$(acrLoginServer)" ] || [ -z "$(acrPassword)" ]; then
            echo "=========================================="
            echo "ACR não configurado - Pulando push"
            echo "=========================================="
            echo "Para habilitar:"
            echo "1. Crie o ACR no Azure (use script-infra-provision.sh)"
            echo "2. Configure a variável 'acrPassword' no Azure DevOps"
            echo "=========================================="
            exit 0
          fi
          
          # Verificar se está logado
          if ! docker info | grep -q "$(acrLoginServer)"; then
            echo "Não está logado no ACR. Tentando login..."
            echo "$(acrPassword)" | docker login $(acrLoginServer) --username $(acrName) --password-stdin
          fi
          
          echo "Pushing images to ACR..."
          docker push $(acrLoginServer)/$(imageName):$(imageTag)
          docker push $(acrLoginServer)/$(imageName):latest
          echo ""
          echo "=========================================="
          echo "BUILD SUMMARY"
          echo "=========================================="
          echo "Image: $(acrLoginServer)/$(imageName):$(imageTag)"
          echo "Latest: $(acrLoginServer)/$(imageName):latest"
          echo "Build ID: $(Build.BuildId)"
          echo "=========================================="
    
    # Resumo do build (sempre executa)
    - task: Bash@3
      displayName: 'Build Summary'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          echo ""
          echo "=========================================="
          echo "BUILD COMPLETED"
          echo "=========================================="
          echo "Image local: $(imageName):$(imageTag)"
          echo "Image local: $(imageName):latest"
          echo "Build ID: $(Build.BuildId)"
          if [ -n "$(acrLoginServer)" ] && [ -n "$(acrPassword)" ]; then
            echo "ACR configurado: $(acrLoginServer)"
            echo "Para ver status do push, verifique os steps anteriores"
          else
            echo "ACR: Não configurado ou não disponível"
            echo "Para configurar: Execute script-infra-provision.sh ou crie manualmente no Azure"
          fi
          echo "=========================================="

# =============================================================================
# STAGE 2: DEPLOY (CD)
# =============================================================================
# NOTA: Para o Deploy funcionar, configure:
# 1. Service Connection: Project Settings > Service connections > New > Azure Resource Manager (nome: Azure-Service-Connection)
# 2. Ambiente: Pipelines > Environments > New environment (nome: 'production')
# 3. Variáveis: Configure dbHost, dbPassword, etc. no Azure DevOps (veja CONFIGURACAO_AZURE_DEVOPS.md)
- stage: Deploy
  displayName: 'Deploy to Azure Container Instances'
  dependsOn: Build
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/master')))
  jobs:
  - deployment: DeployJob
    displayName: 'Deploy to ACI'
    pool:
      name: 'self-hosted-pool'
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            displayName: 'Checkout Repository'
          - task: Bash@3
            displayName: 'Verificar/Instalar Azure CLI'
            inputs:
              targetType: 'inline'
              script: |
                echo "Verificando conectividade de rede do agente..."
                if curl -sSf https://www.google.com &> /dev/null; then
                  echo "Conectividade com a internet OK."
                else
                  echo "ERRO: O agente self-hosted não consegue acessar a internet. Por favor, verifique a configuração de rede, firewall e DNS do seu agente."
                  exit 1
                fi

                if command -v az &> /dev/null; then
                  echo "Azure CLI já está instalado:"
                  az --version
                else
                  echo "Instalando Azure CLI... (forçando IPv4 devido a problemas de IPv6)"
                  echo 'APT::Acquire::IPV4Only "true";' | sudo tee /etc/apt/apt.conf.d/99force-ipv4
                  curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
                fi
          - task: AzureCLI@2
            displayName: 'Azure: Login'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Logado no Azure"
                az account show
          - task: AzureCLI@2
            displayName: 'Verificar/Provisionar Infraestrutura'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Verificando recursos Azure..."
                if az group show --name $(azureRG) &> /dev/null; then
                  echo "Resource Group já existe: $(azureRG)"
                else
                  echo "Criando Resource Group..."
                  az group create --name $(azureRG) --location $(location)
                fi
                if az acr show --name $(acrName) --resource-group $(azureRG) &> /dev/null; then
                  echo "ACR já existe: $(acrName)"
                else
                  echo "Criando ACR..."
                  az acr create --resource-group $(azureRG) --name $(acrName) --sku Basic --admin-enabled true
                fi
                echo "Infraestrutura verificada/criada com sucesso!"
          - task: AzureCLI@2
            displayName: 'Deploy to ACI'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Deploying to Azure Container Instances..."
                ACI_GROUP_NAME="ecotask-api-prod"
                if az container show --resource-group $(azureRG) --name $ACI_GROUP_NAME &> /dev/null; then
                  echo "Container já existe. Deletando versão anterior..."
                  az container delete --resource-group $(azureRG) --name $ACI_GROUP_NAME --yes
                fi

                # Captura as variáveis da pipeline para variáveis shell para garantir expansão correta
                # As variáveis já são acessíveis diretamente via ambiente do Bash com o sufixo _ENV
                # Removendo re-atribuições redundantes.

                az container create \
                  --resource-group $(azureRG) \
                  --name $ACI_GROUP_NAME \
                  --image $(acrLoginServer)/$(imageName):$(imageTag) \
                  --os-type Linux \
                  --registry-login-server $(acrLoginServer) \
                  --registry-username $(acrName) \
                  --registry-password "${ACR_PASSWORD_ENV}" \
                  --dns-name-label ecotask-rm556221-$(Build.BuildId) \
                  --ports 8080 \
                  --environment-variables \
                    SPRING_DATASOURCE_URL="jdbc:postgresql://${DB_HOST_ENV}:${DB_PORT_ENV}/${DB_NAME_ENV}" \
                    SPRING_DATASOURCE_USERNAME="${DB_USER_ENV}" \
                    SPRING_DATASOURCE_PASSWORD="${DB_PASSWORD_ENV}" \
                  --cpu 1 \
                  --memory 1.5 \
                  --restart-policy Always
                if [ $? -eq 0 ]; then
                  echo "DEPLOY REALIZADO COM SUCESSO!"
                  FQDN=$(az container show --resource-group $(azureRG) --name $ACI_GROUP_NAME --query ipAddress.fqdn -o tsv)
                  echo "URL: http://$FQDN:8080"
                else
                  echo "ERRO: Falha no deploy!"
                  exit 1
                fi
            env:
              ACR_PASSWORD_ENV: $(acrPassword)
              DB_HOST_ENV: $(dbHost)
              DB_PORT_ENV: $(dbPort)
              DB_NAME_ENV: $(dbName)
              DB_USER_ENV: $(dbUser)
              DB_PASSWORD_ENV: $(dbPassword)

